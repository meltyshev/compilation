{"version":3,"sources":["with-auth.jsx","use-field.js","App.jsx","index.js","App.module.css"],"names":["WrappedComponent","initialValue","useState","value","setValue","useCallback","_","nextValue","FORMATS_MAP","DICTIONARIES_MAP","isAnagram","word1","word2","length","split","sort","join","isPlusogram","word1Sorted","word2Sorted","hasDifference","i","charAt","isMetagram","isMetanagram","replace","isTlenogram","isLogogrif","isLogogrif2","totalDifferences","isLogogrif3","isMetagrif","isBrukva","isTikva","createHybrid2","intersection","slice","toUpperCase","createHybrid3","createHybrid4","createSharada","dictionarySet","word","has","createGolovahvosts","golovahvosts","word1Tail","j","push","createEmptyFormats","selectedFormatsSet","reduce","result","format","getFormats","words","isBidirectional","isIntersection","formats","forEach","wordDictionary","anagrams","plusograms","metagrams","metanagrams","tlenograms","logogrifs","logogrifs2","logogrifs3","metagrifs","brukvas","tikvas","hybrids2","hybrid2","hybrids3","hybrid3","hybrids4","hybrid4","sharadas","sharada","withAuth","database","setDatabase","Set","map","setSelectedFormatsSet","useField","selectedDictionary","handleSelectedDictionaryChange","setSelectedDictionary","handleIsBidirectionalChange","handleWord1Change","handleWord2Change","useDebounce","word1Debounced","word2Debounced","word1Clean","useMemo","trim","toLowerCase","word2Clean","dictionary","set","words1","words2","Object","keys","getIntersectionFormats","endsWith","associations","array","handleSelectedFormatChange","filter","useEffect","a","async","dictionaries","sanstv","sociation","useHotkeys","find","className","styles","header","Container","Grid","padded","Row","Column","width","Form","Input","fluid","autoFocus","placeholder","size","onChange","Modal","trigger","Button","icon","Header","content","Content","Group","grouped","formatLabel","Checkbox","key","label","checked","dictionaryLabel","Radio","Divider","horizontal","as","title","Label","classNames","odd","Loader","active","window","location","hostname","URLSearchParams","search","get","ReactDOM","render","document","getElementById","module","exports"],"mappings":"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","file":"static/js/main.c8ab816f.chunk.js","sourcesContent":["import React, { useMemo } from 'react';\n\nconst HOSTNAME = 'meltyshev.github.io';\nconst TOKEN = '6XqqFD';\n\nexport default WrappedComponent => {\n  const Auth = () => {\n    const isAuthenticated = useMemo(() => {\n      if (process.env.NODE_ENV === 'development') {\n        return true;\n      }\n\n      return window.location.hostname === HOSTNAME\n        && new URLSearchParams(window.location.search).get('token') === TOKEN;\n    }, []);\n\n    if (!isAuthenticated) {\n      return 'Unauthorized';\n    }\n\n    return <WrappedComponent />;\n  };\n\n  return Auth;\n};\n","import { useCallback, useState } from 'react';\n\nexport default (initialValue) => {\n  const [value, setValue] = useState(initialValue);\n\n  const handleChange = useCallback((_, { value: nextValue }) => {\n    setValue(nextValue);\n  }, []);\n\n  return [value, handleChange, setValue];\n};\n","import React, { useCallback, useEffect, useMemo, useState } from 'react';\nimport classNames from 'classnames';\nimport { useDebounce } from 'use-debounce';\nimport { useHotkeys } from 'react-hotkeys-hook';\nimport {\n  Button,\n  Container,\n  Divider,\n  Form,\n  Grid,\n  Header,\n  Input,\n  Label,\n  Loader,\n  Modal,\n} from 'semantic-ui-react';\n\nimport withAuth from './with-auth';\nimport useField from './use-field';\n\nimport styles from './App.module.css';\n\nimport 'semantic-ui-css/semantic.min.css';\n\nconst FORMATS_MAP = [\n  ['anagrams', 'Анаграммы'],\n  ['brukvas', 'Брюквы'],\n  ['hybrids2', 'Гибриды (2)'],\n  ['hybrids3', 'Гибриды (3)'],\n  ['hybrids4', 'Гибриды (4)'],\n  ['golovahvosts', 'Головахвосты'],\n  ['logogrifs', 'Логогрифы'],\n  ['logogrifs2', 'Логогрифы +2'],\n  ['logogrifs3', 'Логогрифы +3'],\n  ['metagrams', 'Метаграммы'],\n  ['metagrifs', 'Метагрифы'],\n  ['metanagrams', 'Метанаграммы'],\n  ['plusograms', 'Плюсограммы'],\n  ['tlenograms', 'Тленограммы'],\n  ['tikvas', 'Тыквы'],\n  ['sharadas', 'Шарады'],\n];\n\nconst DICTIONARIES_MAP = [\n  ['sanstv', 'sanstv.ru'],\n  ['sociation', 'sociation.org'],\n];\n\nconst isAnagram = (word1, word2) => {\n  if (word1.length !== word2.length) {\n    return false;\n  }\n\n  const word1Sorted = word1.split('').sort().join('');\n  const word2Sorted = word2.split('').sort().join('');\n\n  return word1Sorted === word2Sorted;\n};\n\nconst isPlusogram = (word1, word2) => {\n  if (word1.length === 1 || word2.length - word1.length !== 1) {\n    return false;\n  }\n\n  const word1Sorted = word1.split('').sort().join('');\n  const word2Sorted = word2.split('').sort().join('');\n\n  let hasDifference = false;\n  for (let i = 0; i < word2Sorted.length; i++) {\n    if (word1Sorted.charAt(i - +hasDifference) !== word2Sorted.charAt(i)) {\n      if (hasDifference) {\n        return false;\n      }\n\n      hasDifference = true;\n    }\n  }\n\n  return hasDifference;\n};\n\nconst isMetagram = (word1, word2) => {\n  if (word1.length === 1 || word1.length !== word2.length) {\n    return false;\n  }\n\n  let hasDifference = false;\n  for (let i = 0; i < word1.length; i++) {\n    if (word1.charAt(i) !== word2.charAt(i)) {\n      if (hasDifference) {\n        return false;\n      }\n\n      hasDifference = true;\n    }\n  }\n\n  return hasDifference;\n};\n\nconst isMetanagram = (word1, word2) => {\n  if (word1.length === 1 || word1.length !== word2.length) {\n    return false;\n  }\n\n  for (let i = 0; i < word1.length; i++) {\n    word2 = word2.replace(word1.charAt(i), '');\n  }\n\n  return word2.length === 1;\n};\n\nconst isTlenogram = (word1, word2) => {\n  if (word1.length === 1 || word2.length - word1.length !== 1) {\n    return false;\n  }\n\n  for (let i = 0; i < word1.length; i++) {\n    word2 = word2.replace(word1.charAt(i), '');\n  }\n\n  return word2.length === 2;\n};\n\nconst isLogogrif = (word1, word2) => {\n  if (word1.length === 1 || word2.length - word1.length !== 1) {\n    return false;\n  }\n\n  let hasDifference = false;\n  for (let i = 0; i < word2.length; i++) {\n    if (word1.charAt(i - +hasDifference) !== word2.charAt(i)) {\n      if (hasDifference) {\n        return false;\n      }\n\n      hasDifference = true;\n    }\n  }\n\n  return hasDifference;\n};\n\nconst isLogogrif2 = (word1, word2) => {\n  if (word1.length === 1 || word2.length - word1.length !== 2) {\n    return false;\n  }\n\n  let totalDifferences = 0;\n  for (let i = 0; i < word2.length; i++) {\n    if (word1.charAt(i - totalDifferences) === word2.charAt(i)) {\n      if (totalDifferences > 0) {\n        return false;\n      }\n    } else {\n      if (totalDifferences === 2) {\n        return false;\n      }\n\n      totalDifferences++;\n    }\n  }\n\n  return totalDifferences === 2;\n};\n\nconst isLogogrif3 = (word1, word2) => {\n  if (word1.length === 1 || word2.length - word1.length !== 3) {\n    return false;\n  }\n\n  let totalDifferences = 0;\n  for (let i = 0; i < word2.length; i++) {\n    if (word1.charAt(i - totalDifferences) === word2.charAt(i)) {\n      if (totalDifferences === 1 || totalDifferences === 2) {\n        return false;\n      }\n    } else {\n      if (totalDifferences === 3) {\n        return false;\n      }\n\n      totalDifferences++;\n    }\n  }\n\n  return totalDifferences === 3;\n};\n\nconst isMetagrif = (word1, word2) => {\n  if (word1.length === 1 || word2.length - word1.length !== 1) {\n    return false;\n  }\n\n  let totalDifferences = 0;\n  for (let i = 0; i < word2.length; i++) {\n    if (word1.charAt(i - +!!totalDifferences) !== word2.charAt(i)) {\n      totalDifferences++;\n\n      if (totalDifferences > 2) {\n        break;\n      }\n    }\n  }\n\n  if (totalDifferences === 2) {\n    return true;\n  }\n\n  totalDifferences = 0;\n  for (let i = 0; i < word2.length; i++) {\n    if (word1.charAt(i - +(totalDifferences === 2)) !== word2.charAt(i)) {\n      if (totalDifferences === 2) {\n        return false;\n      }\n\n      totalDifferences++;\n    }\n  }\n\n  return totalDifferences === 2;\n};\n\nconst isBrukva = (word1, word2) => {\n  if (word1.length === 1 || word2.length - word1.length !== 1) {\n    return false;\n  }\n\n  let totalDifferences = 0;\n  for (let i = 0; i < word2.length; i++) {\n    if (word1.charAt(i - +!!totalDifferences) === word2.charAt(i)) {\n      if (totalDifferences === 1) {\n        return false;\n      }\n    } else {\n      if (totalDifferences === 2) {\n        return false;\n      }\n\n      totalDifferences++;\n    }\n  }\n\n  return totalDifferences === 2;\n};\n\nconst isTikva = (word1, word2) => {\n  if (word1.length <= 2 || word2.length - word1.length !== 1) {\n    return false;\n  }\n\n  let totalDifferences = 0;\n  for (let i = 0; i < word2.length; i++) {\n    if (word1.charAt(i - +!!totalDifferences) === word2.charAt(i)) {\n      if (totalDifferences === 1 || totalDifferences === 2) {\n        return false;\n      }\n    } else {\n      if (totalDifferences === 3) {\n        return false;\n      }\n\n      totalDifferences++;\n    }\n  }\n\n  return totalDifferences === 3;\n};\n\nconst createHybrid2 = (word1, word2) => {\n  if (word1.length <= 2 || word2.length <= 2) {\n    return null;\n  }\n\n  const intersection = word1.slice(-2);\n  if (word2.slice(0, 2) === intersection) {\n    return word1.slice(0, -2) + intersection.toUpperCase() + word2.slice(2);\n  }\n\n  return null;\n};\n\nconst createHybrid3 = (word1, word2) => {\n  if (word1.length <= 3 || word2.length <= 3) {\n    return null;\n  }\n\n  const intersection = word1.slice(-3);\n  if (word2.slice(0, 3) === intersection) {\n    return word1.slice(0, -3) + intersection.toUpperCase() + word2.slice(3);\n  }\n\n  return null;\n};\n\nconst createHybrid4 = (word1, word2) => {\n  if (word1.length <= 4 || word2.length <= 4) {\n    return null;\n  }\n\n  const intersection = word1.slice(-4);\n  if (word2.slice(0, 4) === intersection) {\n    return word1.slice(0, -4) + intersection.toUpperCase() + word2.slice(4);\n  }\n\n  return null;\n};\n\nconst createSharada = (word1, word2, dictionarySet) => {\n  const word = word1 + word2;\n  if (dictionarySet.has(word)) {\n    return word;\n  }\n\n  return null;\n};\n\nconst createGolovahvosts = (word1, word2, dictionarySet) => {\n  if (word1.length <= 3 || word2.length <= 3) {\n    return [];\n  }\n\n  const golovahvosts = [];\n  for (let i = word1.length - 1; i >= 3; i--) {\n    const word1Tail = word1.slice(-i);\n\n    for (let j = word2.length - 1; j >= 3; j--) {\n      const word = word1Tail + word2.slice(0, j);\n      if (dictionarySet.has(word)) {\n        golovahvosts.push(\n          word1.slice(0, word1.length - i) + word.toUpperCase() + word2.slice(j - word2.length),\n        );\n      }\n    }\n  }\n\n  return golovahvosts;\n};\n\nconst createEmptyFormats = (selectedFormatsSet) => {\n  return FORMATS_MAP.reduce((result, [format]) => {\n    if (selectedFormatsSet.has(format)) {\n      return {\n        ...result,\n        [format]: [],\n      };\n    }\n\n    return result;\n  }, {});\n};\n\nconst getFormats = (word, words, dictionarySet, selectedFormatsSet, isBidirectional, isIntersection = false) => {\n  const formats = createEmptyFormats(selectedFormatsSet);\n\n  if (word.length > 0) {\n    words.forEach((wordDictionary) => {\n      if (wordDictionary === word) {\n        return;\n      }\n\n      const result = isIntersection ? `${word} ${wordDictionary}` : wordDictionary;\n\n      if (formats.anagrams && isAnagram(word, wordDictionary)) {\n        formats.anagrams.push(result);\n      }\n\n      if (\n        formats.plusograms &&\n        (isPlusogram(word, wordDictionary) || (isBidirectional && isPlusogram(wordDictionary, word)))\n      ) {\n        formats.plusograms.push(result);\n      }\n\n      if (formats.metagrams && isMetagram(word, wordDictionary)) {\n        formats.metagrams.push(result);\n      }\n\n      if (\n        formats.metanagrams &&\n        (isMetanagram(word, wordDictionary) || (isBidirectional && isMetanagram(wordDictionary, word)))\n      ) {\n        formats.metanagrams.push(result);\n      }\n\n      if (\n        formats.tlenograms &&\n        (isTlenogram(word, wordDictionary) || (isBidirectional && isTlenogram(wordDictionary, word)))\n      ) {\n        formats.tlenograms.push(result);\n      }\n\n      if (\n        formats.logogrifs &&\n        (isLogogrif(word, wordDictionary) || (isBidirectional && isLogogrif(wordDictionary, word)))\n      ) {\n        formats.logogrifs.push(result);\n      }\n\n      if (\n        formats.logogrifs2 &&\n        (isLogogrif2(word, wordDictionary) || (isBidirectional && isLogogrif2(wordDictionary, word)))\n      ) {\n        formats.logogrifs2.push(result);\n      }\n\n      if (\n        formats.logogrifs3 &&\n        (isLogogrif3(word, wordDictionary) || (isBidirectional && isLogogrif3(wordDictionary, word)))\n      ) {\n        formats.logogrifs3.push(result);\n      }\n\n      if (\n        formats.metagrifs &&\n        (isMetagrif(word, wordDictionary) || (isBidirectional && isMetagrif(wordDictionary, word)))\n      ) {\n        formats.metagrifs.push(result);\n      }\n\n      if (formats.brukvas && (isBrukva(word, wordDictionary) || (isBidirectional && isBrukva(wordDictionary, word)))) {\n        formats.brukvas.push(result);\n      }\n\n      if (formats.tikvas && (isTikva(word, wordDictionary) || (isBidirectional && isTikva(wordDictionary, word)))) {\n        formats.tikvas.push(result);\n      }\n\n      if (formats.hybrids2 && isIntersection) {\n        let hybrid2 = createHybrid2(word, wordDictionary);\n        if (hybrid2) {\n          formats.hybrids2.push(hybrid2);\n        }\n\n        if (isBidirectional) {\n          hybrid2 = createHybrid2(wordDictionary, word);\n          if (hybrid2) {\n            formats.hybrids2.push(hybrid2);\n          }\n        }\n      }\n\n      if (formats.hybrids3 && isIntersection) {\n        let hybrid3 = createHybrid3(word, wordDictionary);\n        if (hybrid3) {\n          formats.hybrids3.push(hybrid3);\n        }\n\n        if (isBidirectional) {\n          hybrid3 = createHybrid3(wordDictionary, word);\n          if (hybrid3) {\n            formats.hybrids3.push(hybrid3);\n          }\n        }\n      }\n\n      if (formats.hybrids4 && isIntersection) {\n        let hybrid4 = createHybrid4(word, wordDictionary);\n        if (hybrid4) {\n          formats.hybrids4.push(hybrid4);\n        }\n\n        if (isBidirectional) {\n          hybrid4 = createHybrid4(wordDictionary, word);\n          if (hybrid4) {\n            formats.hybrids4.push(hybrid4);\n          }\n        }\n      }\n\n      if (formats.sharadas) {\n        let sharada = createSharada(word, wordDictionary, dictionarySet);\n        if (sharada) {\n          formats.sharadas.push(sharada);\n        }\n\n        if (isBidirectional) {\n          sharada = createSharada(wordDictionary, word, dictionarySet);\n          if (sharada) {\n            formats.sharadas.push(sharada);\n          }\n        }\n      }\n\n      if (formats.golovahvosts && isIntersection) {\n        formats.golovahvosts.push(...createGolovahvosts(word, wordDictionary, dictionarySet));\n\n        if (isBidirectional) {\n          formats.golovahvosts.push(...createGolovahvosts(wordDictionary, word, dictionarySet));\n        }\n      }\n    });\n  }\n\n  return formats;\n};\n\nconst getIntersectionFormats = (words1, words2, dictionarySet, selectedFormatsSet, isBidirectional) => {\n  return words1.reduce((result, word1) => {\n    const formats = getFormats(word1, words2, dictionarySet, selectedFormatsSet, isBidirectional, true);\n\n    Object.keys(result).forEach((format) => {\n      result[format].push(...formats[format]);\n    });\n\n    return result;\n  }, createEmptyFormats(selectedFormatsSet));\n};\n\nconst App = () => {\n  const [database, setDatabase] = useState(null);\n\n  const [selectedFormatsSet, setSelectedFormatsSet] = useState(\n    new Set(FORMATS_MAP.map(([format]) => format)),\n  );\n\n  const [selectedDictionary, handleSelectedDictionaryChange, setSelectedDictionary] = useField(\n    'sanstv',\n  );\n\n  const [isBidirectional, handleIsBidirectionalChange] = useField(true);\n\n  const [word1, handleWord1Change] = useField('');\n  const [word2, handleWord2Change] = useField('');\n\n  const [word1Debounced] = useDebounce(word1, 500);\n  const [word2Debounced] = useDebounce(word2, 500);\n\n  const word1Clean = useMemo(() => word1Debounced.trim().toLowerCase().replace('ё', 'е'), [\n    word1Debounced,\n  ]);\n\n  const word2Clean = useMemo(() => word2Debounced.trim().toLowerCase().replace('ё', 'е'), [\n    word2Debounced,\n  ]);\n\n  const formats = useMemo(() => {\n    if (!database) {\n      return {};\n    }\n\n    const dictionarySet = database.dictionary[selectedDictionary].set;\n\n    if (word2Clean) {\n      const words1 = word1Clean.endsWith('!')\n        ? [word1Clean.slice(0, -1)]\n        : [word1Clean, ...(database.associations[word1Clean] || [])];\n\n      const words2 = word2Clean.endsWith('!')\n        ? [word2Clean.slice(0, -1)]\n        : [word2Clean, ...(database.associations[word2Clean] || [])];\n\n      return getIntersectionFormats(words1, words2, dictionarySet, selectedFormatsSet, isBidirectional);\n    }\n\n    return getFormats(\n      word1Clean,\n      database.dictionary[selectedDictionary].array,\n      dictionarySet,\n      selectedFormatsSet,\n      isBidirectional,\n    );\n  }, [database, selectedFormatsSet, selectedDictionary, isBidirectional, word1Clean, word2Clean]);\n\n  const handleSelectedFormatChange = useCallback(\n    (_, { value }) => {\n      if (selectedFormatsSet.has(value)) {\n        setSelectedFormatsSet(\n          new Set([...selectedFormatsSet].filter((format) => format !== value)),\n        );\n      } else {\n        setSelectedFormatsSet(new Set([...selectedFormatsSet, value]));\n      }\n    },\n    [selectedFormatsSet],\n  );\n\n  useEffect(() => {\n    (async () => {\n      const { dictionaries, associations } = await import('./database.json');\n\n      setDatabase({\n        dictionary: {\n          sanstv: {\n            array: dictionaries.sanstv,\n            set: new Set(dictionaries.sanstv),\n          },\n          sociation: {\n            array: dictionaries.sociation,\n            set: new Set(dictionaries.sociation),\n          },\n        },\n        associations,\n      });\n    })();\n  }, []);\n\n  useHotkeys(\n    'alt+space',\n    () => {\n      setSelectedDictionary(\n        DICTIONARIES_MAP.find(([dictionary]) => dictionary !== selectedDictionary)[0],\n      );\n    },\n    [selectedDictionary],\n  );\n\n  if (!database) {\n    return <Loader active>Загружаю базу...</Loader>;\n  }\n\n  return (\n    <>\n      <div className={styles.header}>\n        <Container>\n          <Grid padded>\n            <Grid.Row>\n              <Grid.Column width={8}>\n                <Form>\n                  <Input\n                    fluid\n                    autoFocus\n                    value={word1}\n                    placeholder=\"Слово\"\n                    size=\"big\"\n                    onChange={handleWord1Change}\n                  />\n                </Form>\n              </Grid.Column>\n              <Grid.Column width={7}>\n                <Form>\n                  <Input\n                    fluid\n                    value={word2}\n                    placeholder=\"Второе слово (пересечение по ассоциатору)\"\n                    size=\"big\"\n                    onChange={handleWord2Change}\n                  />\n                </Form>\n              </Grid.Column>\n              <Grid.Column width={1}>\n                <Modal size=\"mini\" trigger={<Button size=\"big\" icon=\"setting\" />}>\n                  <Header icon=\"setting\" content=\"Настройки\" />\n                  <Modal.Content>\n                    <Form>\n                      <Form.Group grouped>\n                        <label>Форматы</label>\n                        {FORMATS_MAP.map(([format, formatLabel]) => (\n                          <Form.Checkbox\n                            key={format}\n                            value={format}\n                            label={formatLabel}\n                            checked={selectedFormatsSet.has(format)}\n                            onChange={handleSelectedFormatChange}\n                          />\n                        ))}\n                      </Form.Group>\n                      <Form.Group grouped>\n                        <label>Словарь</label>\n                        {DICTIONARIES_MAP.map(([dictionary, dictionaryLabel]) => (\n                          <Form.Radio\n                            key={dictionary}\n                            value={dictionary}\n                            label={dictionaryLabel}\n                            checked={dictionary === selectedDictionary}\n                            onChange={handleSelectedDictionaryChange}\n                          />\n                        ))}\n                      </Form.Group>\n                      <Form.Group grouped>\n                        <label>Тип связи</label>\n                        <Form.Checkbox\n                          value={!isBidirectional}\n                          label=\"Двунаправленная\"\n                          checked={isBidirectional}\n                          onChange={handleIsBidirectionalChange}\n                        />\n                      </Form.Group>\n                    </Form>\n                  </Modal.Content>\n                </Modal>\n              </Grid.Column>\n            </Grid.Row>\n          </Grid>\n        </Container>\n      </div>\n      <div className={styles.content}>\n        <Container>\n          <Grid padded>\n            {FORMATS_MAP.filter(([format]) => formats[format] && formats[format].length > 0).map(\n              ([format, formatLabel]) => (\n                <Grid.Row key={format}>\n                  <Grid.Column>\n                    <Divider horizontal>\n                      <Header as=\"h4\" className={styles.title}>\n                        {formatLabel}\n                      </Header>\n                    </Divider>\n                    <div className={styles.words}>\n                      {formats[format].map((word, i) => (\n                        <Label\n                          horizontal\n                          key={word}\n                          className={classNames(styles.word, i % 2 && styles.odd)}\n                        >\n                          {word}\n                        </Label>\n                      ))}\n                    </div>\n                  </Grid.Column>\n                </Grid.Row>\n              ),\n            )}\n          </Grid>\n        </Container>\n      </div>\n    </>\n  );\n};\n\nexport default withAuth(App);\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"header\":\"App_header__3ZZ1n\",\"content\":\"App_content__3La4L\",\"title\":\"App_title__-GfWs\",\"words\":\"App_words__1Oqw2\",\"word\":\"App_word__3aQvw\",\"odd\":\"App_odd__2GTiD\"};"],"sourceRoot":""}